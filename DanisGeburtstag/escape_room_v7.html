<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Die Verbotene Abteilung</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Georgia', serif;
        }

        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* === CROSSHAIR === */
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(212, 196, 168, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
            display: none;
            box-shadow: 0 0 8px rgba(212, 196, 168, 0.4);
        }

        /* === INTERACTION PROMPT === */
        .interaction-prompt {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.75);
            color: #d4c4a8;
            font-size: 14px;
            border: 1px solid rgba(139, 115, 85, 0.5);
            border-radius: 6px;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            z-index: 100;
            backdrop-filter: blur(4px);
        }

        .interaction-prompt.visible { opacity: 1; }

        .interaction-prompt kbd {
            display: inline-block;
            padding: 2px 6px;
            background: rgba(139, 115, 85, 0.3);
            border: 1px solid #8b7355;
            border-radius: 3px;
            margin: 0 4px;
            font-family: monospace;
        }

        /* === STAMINA BAR === */
        .stamina-bar {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 100;
        }

        .stamina-bar.visible { opacity: 1; }

        .stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b7355, #d4a855);
            transition: width 0.1s ease;
            border-radius: 2px;
        }

        /* === HUD === */
        .game-hud {
            position: fixed;
            top: 20px;
            left: 25px;
            z-index: 200;
        }

        .hud-title {
            color: #c4b498;
            font-size: 22px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .hud-progress {
            display: flex;
            gap: 8px;
        }

        .progress-gem {
            width: 18px;
            height: 18px;
            background: rgba(40, 30, 20, 0.8);
            border: 2px solid #5a4a3a;
            border-radius: 3px;
            transform: rotate(45deg);
            transition: all 0.5s ease;
        }

        .progress-gem.active {
            background: radial-gradient(circle at 30% 30%, #ffd700, #b8860b);
            border-color: #ffd700;
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
        }

        /* === CONTROLS === */
        .controls-info {
            position: fixed;
            bottom: 15px;
            left: 20px;
            color: rgba(160, 140, 110, 0.5);
            font-size: 11px;
            z-index: 100;
            letter-spacing: 1px;
        }

        /* === INTRO === */
        .intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a1510 0%, #000 100%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1.5s ease;
        }

        .intro-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .intro-title {
            color: #c4b498;
            font-size: 48px;
            letter-spacing: 6px;
            margin-bottom: 8px;
            text-shadow: 0 0 50px rgba(180, 150, 100, 0.4);
            animation: breathe 4s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% { text-shadow: 0 0 50px rgba(180, 150, 100, 0.3); }
            50% { text-shadow: 0 0 80px rgba(200, 170, 120, 0.5); }
        }

        .intro-subtitle {
            color: #8b7355;
            font-size: 16px;
            font-style: italic;
            margin-bottom: 50px;
            letter-spacing: 2px;
        }

        .intro-button {
            padding: 16px 50px;
            font-size: 16px;
            background: transparent;
            color: #c4b498;
            border: 1px solid #8b7355;
            cursor: pointer;
            font-family: 'Georgia', serif;
            letter-spacing: 4px;
            text-transform: uppercase;
            transition: all 0.4s ease;
        }

        .intro-button:hover {
            background: rgba(139, 115, 85, 0.15);
            border-color: #c4b498;
            box-shadow: 0 0 30px rgba(139, 115, 85, 0.3);
            letter-spacing: 6px;
        }

        /* === BOOK POPUP === */
        .book-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 450px;
            padding: 25px 35px;
            background: linear-gradient(135deg, rgba(35, 25, 18, 0.95) 0%, rgba(20, 15, 10, 0.95) 100%);
            border: 1px solid #8b7355;
            border-radius: 8px;
            color: #d4c4a8;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(8px);
        }

        .book-popup.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .book-popup h3 {
            margin-bottom: 12px;
            color: #e0d0b8;
            font-size: 18px;
            border-bottom: 1px solid rgba(139, 115, 85, 0.3);
            padding-bottom: 8px;
        }

        .book-popup p {
            font-style: italic;
            line-height: 1.7;
            font-size: 14px;
        }

        .book-popup .close-hint {
            margin-top: 15px;
            text-align: center;
            font-size: 11px;
            color: #6a5a4a;
        }

        /* === SETTINGS PANEL === */
        .settings-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 15, 10, 0.9);
            border: 1px solid #5a4a3a;
            border-radius: 8px;
            padding: 15px 20px;
            z-index: 300;
            color: #d4c4a8;
            font-size: 12px;
            display: none;
        }

        .settings-panel.visible { display: block; }

        .settings-panel h4 {
            margin-bottom: 12px;
            color: #c4b498;
            font-size: 14px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .setting-row input[type="range"] {
            width: 100px;
            margin-left: 10px;
        }

        .settings-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 30px;
            height: 30px;
            background: rgba(20, 15, 10, 0.7);
            border: 1px solid #5a4a3a;
            border-radius: 5px;
            color: #d4c4a8;
            cursor: pointer;
            z-index: 250;
            font-size: 16px;
        }
    </style>
</head>
<body>

<!-- INTRO -->
<div class="intro-overlay" id="introOverlay">
    <h1 class="intro-title">Die Verbotene Abteilung</h1>
    <p class="intro-subtitle">Eine mystische Bibliothek erwartet dich...</p>
    <button class="intro-button" onclick="startGame()">Betreten</button>
</div>

<!-- CANVAS -->
<canvas id="game-canvas"></canvas>

<!-- CROSSHAIR -->
<div class="crosshair" id="crosshair"></div>

<!-- INTERACTION PROMPT -->
<div class="interaction-prompt" id="interactionPrompt">
    <kbd>E</kbd> Interagieren
</div>

<!-- STAMINA BAR -->
<div class="stamina-bar" id="staminaBar">
    <div class="stamina-fill" id="staminaFill" style="width: 100%"></div>
</div>

<!-- HUD -->
<div class="game-hud">
    <h1 class="hud-title">Die Verbotene Abteilung</h1>
    <div class="hud-progress">
        <div class="progress-gem" data-game="1"></div>
        <div class="progress-gem" data-game="2"></div>
        <div class="progress-gem" data-game="3"></div>
        <div class="progress-gem" data-game="4"></div>
        <div class="progress-gem" data-game="5"></div>
        <div class="progress-gem" data-game="6"></div>
        <div class="progress-gem" data-game="7"></div>
    </div>
</div>

<!-- CONTROLS -->
<div class="controls-info">
    WASD Bewegen ‚Ä¢ SHIFT Sprint ‚Ä¢ E Interagieren ‚Ä¢ Maus Umsehen
</div>

<!-- SETTINGS TOGGLE -->
<button class="settings-toggle" id="settingsToggle" onclick="toggleSettings()">‚öô</button>

<!-- SETTINGS PANEL -->
<div class="settings-panel" id="settingsPanel">
    <h4>Einstellungen</h4>
    <div class="setting-row">
        <span>Gehgeschw.</span>
        <input type="range" id="walkSpeedSlider" min="1" max="4" step="0.1" value="2">
    </div>
    <div class="setting-row">
        <span>Maussensitivit√§t</span>
        <input type="range" id="sensitivitySlider" min="0.5" max="3" step="0.1" value="1">
    </div>
    <div class="setting-row">
        <span>Bloom</span>
        <input type="range" id="bloomSlider" min="0" max="2" step="0.1" value="0.8">
    </div>
    <div class="setting-row">
        <span>Nebel</span>
        <input type="range" id="fogSlider" min="10" max="50" step="1" value="22">
    </div>
</div>

<!-- BOOK POPUP -->
<div class="book-popup" id="bookPopup">
    <h3 id="bookTitle">Altes Buch</h3>
    <p id="bookText">Der Text ist verblasst...</p>
    <div class="close-hint">ESC oder Klick zum Schlie√üen</div>
</div>

<!-- MINIGAME MODALS -->
<link rel="stylesheet" href="minigames.css">

<!-- All minigame modals (simplified) -->
<div class="minigame-modal" id="minigame1">
    <div class="modal-content" style="max-width: 900px;">
        <div class="modal-header">
            <h2 class="modal-title">üß™ Die Alchemisten-Pr√ºfung</h2>
            <div class="modal-controls">
                <button class="btn btn-hint" onclick="showHint(1)">üí°</button>
                <button class="btn btn-reset" onclick="polyjuiceGame.reset()">üîÑ</button>
                <button class="btn btn-close" onclick="closeMinigame(1)">‚úï</button>
            </div>
        </div>
        <div class="modal-body">
            <p style="text-align: center; color: #d4c4a8; margin-bottom: 20px; font-style: italic;">‚ÄûOrdne die Zutaten den richtigen Kesseln zu..."</p>
            <div style="background: rgba(139, 115, 85, 0.2); padding: 15px; border-radius: 8px; margin-bottom: 20px; font-size: 14px; color: #d4c4a8;">
                <p>üìú <strong>Hinweise:</strong></p>
                <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                    <li>Fluxkraut darf NICHT in den Kupferkessel</li>
                    <li>Blutegel geh√∂ren direkt RECHTS neben den Kessel mit Fluxkraut</li>
                    <li>Florfliegen brauchen die h√∂chste Temperatur (Stein speichert Hitze am besten)</li>
                </ul>
            </div>
            <div style="display: flex; justify-content: center; gap: 30px; margin-bottom: 30px;">
                <div style="text-align: center;"><div class="cauldron" data-cauldron="copper" style="width: 100px; height: 120px; background: linear-gradient(135deg, #b87333, #8b5a2b); border-radius: 10px 10px 50px 50px; display: flex; align-items: center; justify-content: center; font-size: 30px; border: 3px solid #cd7f32; box-shadow: inset 0 -20px 30px rgba(0,0,0,0.3);"></div><p style="margin-top: 8px; color: #cd7f32;">Kupfer</p></div>
                <div style="text-align: center;"><div class="cauldron" data-cauldron="iron" style="width: 100px; height: 120px; background: linear-gradient(135deg, #5a5a5a, #3a3a3a); border-radius: 10px 10px 50px 50px; display: flex; align-items: center; justify-content: center; font-size: 30px; border: 3px solid #6a6a6a; box-shadow: inset 0 -20px 30px rgba(0,0,0,0.3);"></div><p style="margin-top: 8px; color: #8a8a8a;">Eisen</p></div>
                <div style="text-align: center;"><div class="cauldron" data-cauldron="tin" style="width: 100px; height: 120px; background: linear-gradient(135deg, #8a8a8a, #6a6a6a); border-radius: 10px 10px 50px 50px; display: flex; align-items: center; justify-content: center; font-size: 30px; border: 3px solid #9a9a9a; box-shadow: inset 0 -20px 30px rgba(0,0,0,0.3);"></div><p style="margin-top: 8px; color: #aaaaaa;">Zinn</p></div>
                <div style="text-align: center;"><div class="cauldron" data-cauldron="stone" style="width: 100px; height: 120px; background: linear-gradient(135deg, #6a5a4a, #4a3a2a); border-radius: 10px 10px 50px 50px; display: flex; align-items: center; justify-content: center; font-size: 30px; border: 3px solid #7a6a5a; box-shadow: inset 0 -20px 30px rgba(0,0,0,0.3);"></div><p style="margin-top: 8px; color: #9a8a7a;">Stein</p></div>
            </div>
            <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                <div class="ingredient" draggable="true" data-ingredient="fluxweed" style="padding: 15px 20px; background: linear-gradient(135deg, #2d5a27, #1a3a17); border: 2px solid #4a8a44; border-radius: 10px; cursor: grab; display: flex; flex-direction: column; align-items: center; gap: 5px;"><span style="font-size: 30px;">üåø</span><span style="color: #8fbc8f; font-size: 12px;">Fluxkraut</span></div>
                <div class="ingredient" draggable="true" data-ingredient="knotgrass" style="padding: 15px 20px; background: linear-gradient(135deg, #3a5a2a, #2a4a1a); border: 2px solid #5a8a4a; border-radius: 10px; cursor: grab; display: flex; flex-direction: column; align-items: center; gap: 5px;"><span style="font-size: 30px;">üåæ</span><span style="color: #9acd32; font-size: 12px;">Kn√∂terich</span></div>
                <div class="ingredient" draggable="true" data-ingredient="lacewing" style="padding: 15px 20px; background: linear-gradient(135deg, #4a3a5a, #3a2a4a); border: 2px solid #6a5a7a; border-radius: 10px; cursor: grab; display: flex; flex-direction: column; align-items: center; gap: 5px;"><span style="font-size: 30px;">ü¶ã</span><span style="color: #dda0dd; font-size: 12px;">Florfliegen</span></div>
                <div class="ingredient" draggable="true" data-ingredient="leech" style="padding: 15px 20px; background: linear-gradient(135deg, #4a2a2a, #3a1a1a); border: 2px solid #6a3a3a; border-radius: 10px; cursor: grab; display: flex; flex-direction: column; align-items: center; gap: 5px;"><span style="font-size: 30px;">ü©∏</span><span style="color: #cd5c5c; font-size: 12px;">Blutegel</span></div>
            </div>
            <button onclick="polyjuiceGame.check()" style="display: block; margin: 25px auto 0; padding: 12px 30px; font-size: 16px; background: linear-gradient(135deg, #8b4513, #654321); color: #f5e6d3; border: 2px solid #a0522d; border-radius: 10px; cursor: pointer;">üî• Brauen</button>
        </div>
    </div>
</div>

<div class="minigame-modal" id="minigame2"><div class="modal-content" style="max-width: 900px;"><div class="modal-header"><h2 class="modal-title">üìñ Die Fl√ºsternden Buchr√ºcken</h2><div class="modal-controls"><button class="btn btn-hint" onclick="showHint(2)">üí°</button><button class="btn btn-reset" onclick="whisperingBooks.reset()">üîÑ</button><button class="btn btn-close" onclick="closeMinigame(2)">‚úï</button></div></div><div class="modal-body"><div id="whisperingBooksContainer"></div></div></div></div>

<div class="minigame-modal" id="minigame3"><div class="modal-content"><div class="modal-header"><h2 class="modal-title">üîê Die Chiffre</h2><div class="modal-controls"><button class="btn btn-hint" onclick="showHint(3)">üí°</button><button class="btn btn-reset" onclick="initCipher()">üîÑ</button><button class="btn btn-close" onclick="closeMinigame(3)">‚úï</button></div></div><div class="modal-body"><div id="cipherContainer"></div></div></div></div>

<div class="minigame-modal" id="minigame4"><div class="modal-content"><div class="modal-header"><h2 class="modal-title">ü™ú Die Treppen</h2><div class="modal-controls"><button class="btn btn-hint" onclick="showHint(4)">üí°</button><button class="btn btn-reset" onclick="initStaircase()">üîÑ</button><button class="btn btn-close" onclick="closeMinigame(4)">‚úï</button></div></div><div class="modal-body"><div id="staircaseContainer"></div></div></div></div>

<div class="minigame-modal" id="minigame5"><div class="modal-content"><div class="modal-header"><h2 class="modal-title">üïØÔ∏è Geheime Tinte</h2><div class="modal-controls"><button class="btn btn-hint" onclick="showHint(5)">üí°</button><button class="btn btn-reset" onclick="initInvisibleInk()">üîÑ</button><button class="btn btn-close" onclick="closeMinigame(5)">‚úï</button></div></div><div class="modal-body"><p style="text-align: center; color: #d4c4a8; font-style: italic; margin-bottom: 15px;">‚ÄûW√§rme offenbart die Wahrheit..."</p><canvas id="parchmentCanvas" width="400" height="400"></canvas><div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;"><input type="text" id="inkGuessInput" placeholder="Was siehst du?" style="padding: 10px 15px; font-size: 16px; border: 2px solid #8b7355; border-radius: 8px; background: #f5e6d3; color: #4a3520; width: 200px;" onkeypress="if(event.key === 'Enter') checkInvisibleInkGuess(this.value);"><button onclick="checkInvisibleInkGuess(document.getElementById('inkGuessInput').value)" style="padding: 10px 20px; font-size: 16px; background: linear-gradient(135deg, #8b4513, #654321); color: #f5e6d3; border: none; border-radius: 8px; cursor: pointer;">‚ú®</button></div></div></div></div>

<div class="minigame-modal" id="minigame6"><div class="modal-content"><div class="modal-header"><h2 class="modal-title">üîî Die Glocken</h2><div class="modal-controls"><button class="btn btn-hint" onclick="showHint(6)">üí°</button><button class="btn btn-reset" onclick="resetBellGame()">üîÑ</button><button class="btn btn-close" onclick="closeMinigame(6)">‚úï</button></div></div><div class="modal-body"><p style="text-align: center; color: #d4c4a8; font-style: italic; margin-bottom: 15px;">‚ÄûZeit flie√üt auch r√ºckw√§rts..."</p><div id="bellPhase" style="text-align: center; font-size: 14px; margin-bottom: 10px; color: #d4c4a8;"></div><div id="bellContainer"></div></div></div></div>

<div class="minigame-modal" id="minigame7"><div class="modal-content"><div class="modal-header"><h2 class="modal-title">üìö Die Chronik</h2><div class="modal-controls"><button class="btn btn-hint" onclick="showHint(7)">üí°</button><button class="btn btn-reset" onclick="initBookSort()">üîÑ</button><button class="btn btn-close" onclick="closeMinigame(7)">‚úï</button></div></div><div class="modal-body"><p style="text-align: center; color: #d4c4a8; font-style: italic; margin-bottom: 15px;">‚ÄûDie Geschichte muss in der richtigen Reihenfolge erz√§hlt werden..."</p><div id="bookShelf"></div></div></div></div>

<div class="minigame-modal" id="minigame8"><div class="modal-content" style="max-width: 500px;"><div class="modal-header"><h2 class="modal-title">üåÄ Das Denkarium</h2><div class="modal-controls"><button class="btn btn-hint" onclick="showHint(8)">üí°</button><button class="btn btn-close" onclick="closeMinigame(8)">‚úï</button></div></div><div class="modal-body"><div style="text-align: center;"><svg width="200" height="100" viewBox="0 0 200 100"><ellipse cx="100" cy="50" rx="90" ry="40" fill="rgba(100, 130, 180, 0.2)" stroke="#8b7355" stroke-width="3"/></svg></div><div id="penseiveSlots"></div><div id="availableArtifacts"></div></div></div></div>

<!-- THREE.JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- MINIGAME SCRIPTS -->
<script src="games/minigames-core.js"></script>
<script src="games/game1-polyjuice.js"></script>
<script src="games/game2-muffliato.js"></script>
<script src="games/game3-cipher.js"></script>
<script src="games/game4-staircase.js"></script>
<script src="games/game5-invisibleink.js"></script>
<script src="games/game6-bells.js"></script>
<script src="games/game7-booksort.js"></script>
<script src="games/game8-pensieve.js"></script>

<script>
// ============================================================================
// MAGICAL LIBRARY - ENHANCED 3D EXPLORATION
// ============================================================================
// Features:
// - Smooth movement with acceleration/deceleration
// - Head bob and camera sway
// - Sprint with stamina
// - AABB collision detection
// - Thousands of instanced books
// - Rich atmospheric lighting and particles
// - Interactive objects with feedback
// ============================================================================

// === CONFIGURATION (TUNE THESE!) ===
const CONFIG = {
    // Room dimensions
    room: {
        width: 18,
        height: 9,
        depth: 14
    },
    
    // Movement (realistic walking speed: 1.4 m/s, jogging: 2.5 m/s)
    movement: {
        walkSpeed: 3.0,           // Normal walking (m/s)
        sprintSpeed: 4.5,         // Sprinting (m/s)
        acceleration: 12,         // How fast to reach max speed
        deceleration: 10,         // How fast to stop
        mouseSensitivity: 0.001,  // Mouse look speed
    },
    
    // Stamina
    stamina: {
        max: 100,
        drainRate: 25,            // Per second while sprinting
        regenRate: 15,            // Per second while not sprinting
        minToSprint: 10           // Minimum stamina to start sprinting
    },
    
    // Head bob
    headBob: {
        enabled: true,
        walkAmplitude: 0.03,      // Vertical bob amount
        walkFrequency: 8,         // Bob speed when walking
        sprintAmplitude: 0.05,
        sprintFrequency: 12,
        swayAmount: 0.002         // Horizontal camera sway
    },
    
    // Player collision (capsule approximated as cylinder)
    player: {
        radius: 0.35,             // Collision radius
        height: 1.7,              // Eye height
        stepHeight: 0.3           // Can step over small obstacles
    },
    
    // Particles
    particles: {
        dustCount: 600,           // Floating dust motes
        fireCount: 250,           // Fire particles
        emberCount: 50,           // Floating embers
        orbDustCount: 100         // Magical dust near orb
    },
    
    // Lighting (brighter moon for visibility)
    lighting: {
        fireIntensity: 3.0,       // Base fire light intensity
        fireFlickerAmount: 0.6,   // Flicker variation
        moonIntensity: 1.2,       // Moonlight strength (brighter!)
        ambientIntensity: 0.18,   // Base ambient (brighter)
        orbIntensity: 0.8         // Orb glow
    },
    
    // Fog
    fog: {
        near: 2,
        far: 22,
        color: 0x0a0806,
        floorFogOpacity: 0.25
    },
    
    // Books
    books: {
        totalCount: 2000,         // Total instanced books
        colorsSpine: [
            0x8b4513, 0x654321, 0x4a2511, // Browns
            0x2e4a1c, 0x1e3a0c, 0x3e5a2c, // Greens
            0x4a1c2e, 0x5a2c3e, 0x3a0c1e, // Burgundy
            0x1c2e4a, 0x0c1e3a, 0x2c3e5a, // Blues
            0x4a3a1c, 0x5a4a2c, 0x3a2a0c, // Tan
            0x3a3a3a, 0x2a2a2a, 0x1a1a1a  // Dark
        ]
    },
    
    // Post-processing
    postProcessing: {
        bloomStrength: 0.8,
        bloomRadius: 0.4,
        vignetteIntensity: 0.4
    },
    
    // Colors
    colors: {
        woodDark: 0x1a0f08,
        woodMedium: 0x2a1a0a,
        woodLight: 0x4a3520,
        stone: 0x3a3530,
        floor: 0x2a1a0a,
        ceiling: 0x15100a
    },
    
    // Interactive objects
    interactives: {
        fireplace: { game: null, hint: "Das Feuer knistert..." },
        orb: { game: 5, hint: "Ein mystisches Leuchten..." },
        bookshelfLeft: { game: 7, hint: "Die B√ºcher sind ungeordnet..." },
        bookshelfRight: { game: 2, hint: "Diese B√ºcher fl√ºstern..." },
        desk: { game: 3, hint: "Verschl√ºsselte Runen..." },
        potions: { game: 1, hint: "Seltsame Tr√§nke..." },
        bells: { game: 6, hint: "Ein magisches Glockenspiel..." },
        stairs: { game: 4, hint: "Die Treppen bewegen sich..." },
        pensieve: { game: 8, hint: "Das Denkarium...", hidden: true }
    }
};

// === GLOBALS ===
let scene, camera, renderer;
let clock = new THREE.Clock();
let gameStarted = false;
let isPointerLocked = false;

// Movement state
const velocity = new THREE.Vector3();
const inputDirection = new THREE.Vector3();
const euler = new THREE.Euler(0, 0, 0, 'YXZ');
let moveForward = false, moveBackward = false;
let moveLeft = false, moveRight = false;
let isSprinting = false;
let stamina = CONFIG.stamina.max;
let headBobTime = 0;
let baseEyeHeight = CONFIG.player.height;

// Colliders
const colliders = [];
const playerPosition = new THREE.Vector3(0, CONFIG.player.height, 5);

// Objects
let fireParticles, dustParticles, emberParticles, orbDustParticles;
let fireLight, moonLight, orbLight;
let orbGlow;
let interactiveObjects = [];
let currentTarget = null;
let bookInstances = null;
let floatingCandles = [];
let isMinigameOpen = false;

// Audio
let audioCtx = null;
let ambientSource = null;

// UI Elements
const interactionPrompt = document.getElementById('interactionPrompt');
const staminaBar = document.getElementById('staminaBar');
const staminaFill = document.getElementById('staminaFill');
const bookPopup = document.getElementById('bookPopup');
const crosshair = document.getElementById('crosshair');

// Raycaster
const raycaster = new THREE.Raycaster();
const rayDirection = new THREE.Vector3();

// ============================================================================
// INITIALIZATION
// ============================================================================
function init() {
    // Scene
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(CONFIG.fog.color, CONFIG.fog.near, CONFIG.fog.far);
    scene.background = new THREE.Color(CONFIG.fog.color);
    
    // Camera
    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.copy(playerPosition);
    camera.rotation.y = Math.PI; // Face into room
    euler.y = Math.PI;
    
    // Renderer
    const canvas = document.getElementById('game-canvas');
    renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: true,
        powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.85;
    renderer.outputEncoding = THREE.sRGBEncoding;
    
    // Build scene
    createRoom();
    createLighting();
    createFireplace();
    createBookshelves();
    createDesk();
    createMagicOrb();
    createPotionShelf();
    createBells();
    createStairs();
    createMezzanine();
    createProps();
    createDustParticles();
    createFloorFog();
    createFloatingCandles();
    createGodRays();
    
    // Events
    window.addEventListener('resize', onWindowResize);
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('click', onClick);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('pointerlockchange', onPointerLockChange);
    
    // Settings sliders
    setupSettings();
    
    // Start
    animate();
}

// ============================================================================
// ROOM GEOMETRY WITH COLLIDERS
// ============================================================================
function createRoom() {
    const w = CONFIG.room.width;
    const h = CONFIG.room.height;
    const d = CONFIG.room.depth;
    
    // Materials
    const floorMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.floor,
        roughness: 0.85,
        metalness: 0.05
    });
    
    const wallMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.woodDark,
        roughness: 0.75
    });
    
    const ceilMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.ceiling,
        roughness: 0.9
    });
    
    // Floor
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(w, d), floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);
    
    // Floor planks (visual detail)
    const plankMat = new THREE.MeshBasicMaterial({ color: 0x0a0500 });
    for (let x = -w/2; x <= w/2; x += 1.2) {
        const plank = new THREE.Mesh(new THREE.PlaneGeometry(0.015, d), plankMat);
        plank.rotation.x = -Math.PI / 2;
        plank.position.set(x, 0.002, 0);
        scene.add(plank);
    }
    
    // Ceiling
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(w, d), ceilMat);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = h;
    scene.add(ceiling);
    
    // Ceiling beams
    const beamMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodMedium, roughness: 0.7 });
    for (let z = -d/2 + 2; z <= d/2 - 2; z += 3) {
        const beam = new THREE.Mesh(new THREE.BoxGeometry(w, 0.25, 0.3), beamMat);
        beam.position.set(0, h - 0.125, z);
        beam.castShadow = true;
        scene.add(beam);
    }
    
    // Walls
    createWall(0, h/2, -d/2, w, h, 0, 'back');
    createWall(0, h/2, d/2, w, h, Math.PI, 'front');
    createWall(-w/2, h/2, 0, d, h, Math.PI/2, 'left');
    createWall(w/2, h/2, 0, d, h, -Math.PI/2, 'right');
    
    // Wall colliders (invisible barriers)
    addCollider(-w/2 - 0.1, h/2, 0, 0.2, h, d); // Left
    addCollider(w/2 + 0.1, h/2, 0, 0.2, h, d);  // Right
    addCollider(0, h/2, -d/2 - 0.1, w, h, 0.2); // Back
    addCollider(0, h/2, d/2 + 0.1, w, h, 0.2);  // Front
}

function createWall(x, y, z, width, height, rotY, side) {
    const wallMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.woodDark,
        roughness: 0.75
    });
    
    const wall = new THREE.Mesh(new THREE.PlaneGeometry(width, height), wallMat);
    wall.position.set(x, y, z);
    wall.rotation.y = rotY;
    wall.receiveShadow = true;
    scene.add(wall);
    
    // Lower wood paneling
    const panelMat = new THREE.MeshStandardMaterial({ 
        color: CONFIG.colors.woodMedium, 
        roughness: 0.6 
    });
    const panel = new THREE.Mesh(new THREE.PlaneGeometry(width, 2.5), panelMat);
    panel.position.set(x, 1.25, z + (rotY === 0 ? 0.01 : rotY === Math.PI ? -0.01 : 0));
    if (side === 'left') panel.position.x += 0.01;
    if (side === 'right') panel.position.x -= 0.01;
    panel.rotation.y = rotY;
    scene.add(panel);
    
    // Crown molding
    const moldMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodLight, roughness: 0.5 });
    const mold = new THREE.Mesh(new THREE.BoxGeometry(width, 0.15, 0.1), moldMat);
    mold.position.set(x, height - 0.075, z);
    mold.rotation.y = rotY;
    scene.add(mold);
}

function addCollider(x, y, z, w, h, d) {
    colliders.push({
        min: new THREE.Vector3(x - w/2, y - h/2, z - d/2),
        max: new THREE.Vector3(x + w/2, y + h/2, z + d/2)
    });
}

// ============================================================================
// LIGHTING
// ============================================================================
function createLighting() {
    // Ambient (very low, colored)
    const ambient = new THREE.AmbientLight(0x1a1510, CONFIG.lighting.ambientIntensity);
    scene.add(ambient);
    
    // Fireplace light
    fireLight = new THREE.PointLight(0xff6622, CONFIG.lighting.fireIntensity, 14);
    fireLight.position.set(-7.5, 2.5, -5);
    fireLight.castShadow = true;
    fireLight.shadow.mapSize.width = 1024;
    fireLight.shadow.mapSize.height = 1024;
    fireLight.shadow.camera.near = 0.5;
    fireLight.shadow.camera.far = 15;
    fireLight.shadow.bias = -0.001;
    scene.add(fireLight);
    
    // Secondary fire light (fill)
    const fireFill = new THREE.PointLight(0xff4400, 0.8, 8);
    fireFill.position.set(-7, 1, -4);
    scene.add(fireFill);
    
    // Moonlight (directional, cool)
    moonLight = new THREE.DirectionalLight(0x6688aa, CONFIG.lighting.moonIntensity);
    moonLight.position.set(0, 10, -15);
    moonLight.target.position.set(0, 0, 0);
    moonLight.castShadow = true;
    moonLight.shadow.mapSize.width = 2048;
    moonLight.shadow.mapSize.height = 2048;
    moonLight.shadow.camera.near = 1;
    moonLight.shadow.camera.far = 30;
    moonLight.shadow.camera.left = -15;
    moonLight.shadow.camera.right = 15;
    moonLight.shadow.camera.top = 15;
    moonLight.shadow.camera.bottom = -15;
    scene.add(moonLight);
    scene.add(moonLight.target);
}

// ============================================================================
// FIREPLACE (Classic stone fireplace - very recognizable)
// ============================================================================
function createFireplace() {
    const x = -7.5, y = 0, z = -5.5;
    
    // Materials
    const stoneMat = new THREE.MeshStandardMaterial({ color: 0x6a625a, roughness: 0.8 });
    const darkStoneMat = new THREE.MeshStandardMaterial({ color: 0x3a3530, roughness: 0.9 });
    const marbleMat = new THREE.MeshStandardMaterial({ color: 0x8a827a, roughness: 0.4, metalness: 0.1 });
    const brickMat = new THREE.MeshStandardMaterial({ color: 0x6a3a2a, roughness: 0.85 });
    const darkMat = new THREE.MeshBasicMaterial({ color: 0x020202 });
    const goldMat = new THREE.MeshStandardMaterial({ color: 0xc9a227, metalness: 0.7, roughness: 0.3 });
    
    // === MAIN SURROUND (very visible stone frame) ===
    // Left column
    const leftCol = new THREE.Mesh(new THREE.BoxGeometry(0.6, 4.5, 0.6), marbleMat);
    leftCol.position.set(x - 1.6, 2.25, z + 0.3);
    leftCol.castShadow = true;
    scene.add(leftCol);
    
    // Right column
    const rightCol = new THREE.Mesh(new THREE.BoxGeometry(0.6, 4.5, 0.6), marbleMat);
    rightCol.position.set(x + 1.6, 2.25, z + 0.3);
    rightCol.castShadow = true;
    scene.add(rightCol);
    
    // Column caps (decorative tops)
    [-1.6, 1.6].forEach(dx => {
        const cap = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.25, 0.8), stoneMat);
        cap.position.set(x + dx, 4.6, z + 0.3);
        scene.add(cap);
        
        // Decorative ball on top
        const ball = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), goldMat);
        ball.position.set(x + dx, 4.85, z + 0.3);
        scene.add(ball);
    });
    
    // === MANTLE (large prominent shelf) ===
    const mantle = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.35, 1.2), marbleMat);
    mantle.position.set(x, 4.5, z + 0.4);
    mantle.castShadow = true;
    mantle.receiveShadow = true;
    scene.add(mantle);
    
    // Mantle front edge detail
    const mantleEdge = new THREE.Mesh(new THREE.BoxGeometry(4.4, 0.12, 0.15), darkStoneMat);
    mantleEdge.position.set(x, 4.35, z + 0.95);
    scene.add(mantleEdge);
    
    // === FIRE OPENING (the dark hole where fire burns) ===
    // Back wall of fireplace
    const backWall = new THREE.Mesh(new THREE.BoxGeometry(2.8, 3.5, 0.3), darkStoneMat);
    backWall.position.set(x, 1.75, z - 0.1);
    backWall.receiveShadow = true;
    scene.add(backWall);
    
    // Interior brick pattern
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 5; col++) {
            const brick = new THREE.Mesh(
                new THREE.BoxGeometry(0.45, 0.2, 0.08),
                brickMat
            );
            const offsetX = (row % 2) * 0.22;
            brick.position.set(x - 1.0 + col * 0.5 + offsetX, 0.3 + row * 0.25, z + 0.06);
            scene.add(brick);
        }
    }
    
    // Dark fire opening recess
    const opening = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.5, 0.4), darkMat);
    opening.position.set(x, 1.4, z + 0.25);
    scene.add(opening);
    
    // === ARCH over fire opening ===
    const archMat = new THREE.MeshStandardMaterial({ color: 0x5a524a, roughness: 0.6 });
    const arch = new THREE.Mesh(
        new THREE.TorusGeometry(1.1, 0.18, 12, 16, Math.PI),
        archMat
    );
    arch.position.set(x, 2.65, z + 0.5);
    arch.rotation.x = Math.PI / 2;
    arch.castShadow = true;
    scene.add(arch);
    
    // Keystone at top of arch
    const keystone = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 0.25), stoneMat);
    keystone.position.set(x, 3.75, z + 0.5);
    scene.add(keystone);
    
    // === HEARTH (floor in front of fire) ===
    const hearth = new THREE.Mesh(new THREE.BoxGeometry(4, 0.12, 2), darkStoneMat);
    hearth.position.set(x, 0.06, z + 0.8);
    hearth.receiveShadow = true;
    scene.add(hearth);
    
    // Hearth border
    const hearthBorder = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.08, 0.15), stoneMat);
    hearthBorder.position.set(x, 0.16, z + 1.85);
    scene.add(hearthBorder);
    
    // === FIRE GRATE (metal basket for logs) ===
    const grateMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.6, roughness: 0.4 });
    const grateBase = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.05, 0.8), grateMat);
    grateBase.position.set(x, 0.18, z + 0.4);
    scene.add(grateBase);
    
    // Grate bars
    for (let i = 0; i < 5; i++) {
        const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.8, 8), grateMat);
        bar.position.set(x - 0.6 + i * 0.3, 0.18, z + 0.4);
        bar.rotation.x = Math.PI / 2;
        scene.add(bar);
    }
    
    // === LOGS ===
    const logMat = new THREE.MeshStandardMaterial({ color: 0x3a2510, roughness: 0.95 });
    const burntMat = new THREE.MeshStandardMaterial({ color: 0x1a0a00, roughness: 0.9 });
    
    // Main logs
    [[-0.4, 0.35], [0.4, 0.32], [0, 0.45]].forEach(([dx, dz], i) => {
        const mat = i === 2 ? burntMat : logMat;
        const log = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.9, 12), mat);
        log.position.set(x + dx, 0.32, z + dz);
        log.rotation.z = Math.PI / 2 + (Math.random() - 0.5) * 0.2;
        log.rotation.y = (Math.random() - 0.5) * 0.3;
        scene.add(log);
    });
    
    // Small kindling
    for (let i = 0; i < 4; i++) {
        const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.02, 0.4, 6), burntMat);
        stick.position.set(x + (Math.random() - 0.5) * 0.6, 0.22, z + 0.3 + Math.random() * 0.3);
        stick.rotation.set(Math.random() * 0.5, Math.random() * Math.PI, Math.random() * 0.5);
        scene.add(stick);
    }
    
    // === DECORATIONS ON MANTLE ===
    // Candle holders
    [-1.2, 1.2].forEach(dx => {
        const holder = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 0.08, 12), goldMat);
        holder.position.set(x + dx, 4.72, z + 0.4);
        scene.add(holder);
        
        const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.2, 8), 
            new THREE.MeshStandardMaterial({ color: 0xf5ead0 }));
        candle.position.set(x + dx, 4.86, z + 0.4);
        scene.add(candle);
        
        // Flame
        const flame = new THREE.Mesh(new THREE.ConeGeometry(0.025, 0.06, 8),
            new THREE.MeshBasicMaterial({ color: 0xffaa33 }));
        flame.position.set(x + dx, 5.0, z + 0.4);
        scene.add(flame);
        
        floatingCandles.push({ mesh: flame, baseY: 5.0, phase: Math.random() * Math.PI * 2 });
    });
    
    // Clock or mirror frame in center of mantle
    const frameOuter = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.08), goldMat);
    frameOuter.position.set(x, 5.2, z + 0.4);
    scene.add(frameOuter);
    
    const frameInner = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.1), 
        new THREE.MeshBasicMaterial({ color: 0x222222 }));
    frameInner.position.set(x, 5.2, z + 0.42);
    scene.add(frameInner);
    
    addCollider(x, 2.5, z, 4.5, 5, 2);
    
    // Fire particles
    createFireParticles(x, z);
    
    // Ember particles
    createEmberParticles(x, z);
    
    // Soot detail on floor
    const sootGeo = new THREE.PlaneGeometry(2, 1);
    const sootMat = new THREE.MeshBasicMaterial({ 
        color: 0x0a0a0a, 
        transparent: true, 
        opacity: 0.3 
    });
    const soot = new THREE.Mesh(sootGeo, sootMat);
    soot.rotation.x = -Math.PI / 2;
    soot.position.set(x, 0.003, z + 1);
    scene.add(soot);
    
    // Interactive zone
    const interactZone = new THREE.Mesh(
        new THREE.BoxGeometry(3.5, 4, 2.5),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    interactZone.position.set(x, 2, z + 0.5);
    interactZone.userData = { type: 'fireplace', ...CONFIG.interactives.fireplace };
    interactiveObjects.push(interactZone);
    scene.add(interactZone);
}

function createFireParticles(baseX, baseZ) {
    const count = CONFIG.particles.fireCount;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    const sizes = new Float32Array(count);
    
    for (let i = 0; i < count; i++) {
        positions[i * 3] = baseX + (Math.random() - 0.5) * 1.5;
        positions[i * 3 + 1] = 0.3 + Math.random() * 2;
        positions[i * 3 + 2] = baseZ + 0.3 + Math.random() * 0.4;
        
        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 0.2 + Math.random() * 0.5;
        colors[i * 3 + 2] = 0.05;
        
        sizes[i] = 0.08 + Math.random() * 0.15;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    geometry.userData = {
        baseX, baseZ,
        velocities: new Float32Array(count).fill(0).map(() => 0.015 + Math.random() * 0.035),
        lifetimes: new Float32Array(count).fill(0).map(() => Math.random())
    };
    
    const material = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    
    fireParticles = new THREE.Points(geometry, material);
    scene.add(fireParticles);
}

function createEmberParticles(baseX, baseZ) {
    const count = CONFIG.particles.emberCount;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
        positions[i * 3] = baseX + (Math.random() - 0.5) * 3;
        positions[i * 3 + 1] = 1 + Math.random() * 4;
        positions[i * 3 + 2] = baseZ + (Math.random() - 0.5) * 2;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.userData = {
        baseX, baseZ,
        velocities: new Float32Array(count * 3).fill(0).map((_, i) => {
            const axis = i % 3;
            if (axis === 1) return 0.005 + Math.random() * 0.01;
            return (Math.random() - 0.5) * 0.008;
        }),
        lifetimes: new Float32Array(count).fill(0).map(() => Math.random())
    };
    
    const material = new THREE.PointsMaterial({
        size: 0.04,
        color: 0xff6600,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    
    emberParticles = new THREE.Points(geometry, material);
    scene.add(emberParticles);
}

// ============================================================================
// BOOKSHELVES WITH INSTANCED BOOKS
// ============================================================================
function createBookshelves() {
    // Back wall giant bookshelf (the main feature!)
    createGiantBackBookshelf();
    
    // These are now the interactive spots on the giant back shelf (behind player)
    createInteractiveBookZone(-2.5, 4, 6.3, 'bookshelfLeft', CONFIG.interactives.bookshelfLeft);
    createInteractiveBookZone(2.5, 4, 6.3, 'bookshelfRight', CONFIG.interactives.bookshelfRight);
    
    // Side wall shelves
    createBookshelf(-8.8, 0, 0, Math.PI/2, null, null, true);
    createBookshelf(-8.8, 0, 3, Math.PI/2, null, null, true);
    createBookshelf(8.8, 0, 0, -Math.PI/2, null, null, true);
    createBookshelf(8.8, 0, 3, -Math.PI/2, null, null, true);
    
    // Create instanced books for all shelves
    createInstancedBooks();
}

// Giant bookshelf covering BACK wall (behind the player's start position)
function createGiantBackBookshelf() {
    const shelfWidth = 15;  // Almost entire back wall
    const shelfHeight = 8.5;
    const shelfDepth = 0.9;
    const x = 0, z = 6.5;  // BACK wall (positive z, behind player start)
    
    const frameMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.woodDark,
        roughness: 0.7
    });
    const shelfMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.woodMedium,
        roughness: 0.6
    });
    const accentMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.woodLight,
        roughness: 0.5
    });
    
    // Main back panel
    const backPanel = new THREE.Mesh(
        new THREE.BoxGeometry(shelfWidth, shelfHeight, 0.15),
        frameMat
    );
    backPanel.position.set(x, shelfHeight/2, z - shelfDepth/2);
    backPanel.receiveShadow = true;
    scene.add(backPanel);
    
    // Vertical dividers (creating sections)
    const dividerPositions = [-6, -3, 0, 3, 6];
    dividerPositions.forEach(dx => {
        const divider = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, shelfHeight, shelfDepth),
            shelfMat
        );
        divider.position.set(x + dx, shelfHeight/2, z);
        divider.castShadow = true;
        scene.add(divider);
    });
    
    // Side frames
    [-shelfWidth/2, shelfWidth/2].forEach(dx => {
        const side = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, shelfHeight, shelfDepth + 0.1),
            frameMat
        );
        side.position.set(x + dx, shelfHeight/2, z);
        side.castShadow = true;
        scene.add(side);
    });
    
    // Horizontal shelves
    for (let sy = 0.8; sy <= 7.8; sy += 1.0) {
        const shelf = new THREE.Mesh(
            new THREE.BoxGeometry(shelfWidth - 0.2, 0.06, shelfDepth - 0.1),
            shelfMat
        );
        shelf.position.set(x, sy, z);
        shelf.receiveShadow = true;
        scene.add(shelf);
    }
    
    // Top crown molding
    const crown = new THREE.Mesh(
        new THREE.BoxGeometry(shelfWidth + 0.3, 0.25, shelfDepth + 0.2),
        accentMat
    );
    crown.position.set(x, shelfHeight + 0.125, z);
    scene.add(crown);
    
    // Decorative top piece
    const topDeco = new THREE.Mesh(
        new THREE.BoxGeometry(shelfWidth + 0.1, 0.12, 0.15),
        accentMat
    );
    topDeco.position.set(x, shelfHeight + 0.3, z + shelfDepth/2);
    scene.add(topDeco);
    
    // Base molding
    const base = new THREE.Mesh(
        new THREE.BoxGeometry(shelfWidth + 0.2, 0.15, shelfDepth + 0.15),
        accentMat
    );
    base.position.set(x, 0.075, z);
    scene.add(base);
    
    // Collider for the whole shelf
    addCollider(x, shelfHeight/2, z, shelfWidth, shelfHeight, shelfDepth + 0.3);
}

// Interactive zone for book sections
function createInteractiveBookZone(x, y, z, name, config) {
    const interactZone = new THREE.Mesh(
        new THREE.BoxGeometry(2.5, 3, 1.5),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    interactZone.position.set(x, y, z + 0.5);
    interactZone.userData = { type: name, ...config };
    interactiveObjects.push(interactZone);
    scene.add(interactZone);
}

function createBookshelf(x, y, z, rotY, name, config, decorative = false) {
    const group = new THREE.Group();
    group.position.set(x, y, z);
    group.rotation.y = rotY;
    
    const frameMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.woodDark,
        roughness: 0.7
    });
    const shelfMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.woodMedium,
        roughness: 0.6
    });
    
    // Main frame
    const frame = new THREE.Mesh(new THREE.BoxGeometry(4.5, 8, 0.9), frameMat);
    frame.position.y = 4;
    frame.castShadow = true;
    frame.receiveShadow = true;
    group.add(frame);
    
    // Top decorative crown
    const crown = new THREE.Mesh(new THREE.BoxGeometry(4.8, 0.2, 1), shelfMat);
    crown.position.set(0, 8, 0);
    group.add(crown);
    
    // Shelves
    for (let sy = 0.8; sy <= 7.2; sy += 1.1) {
        const shelf = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.08, 0.75), shelfMat);
        shelf.position.set(0, sy, 0.1);
        shelf.receiveShadow = true;
        group.add(shelf);
    }
    
    // Side pillars
    const pillarGeo = new THREE.BoxGeometry(0.15, 8, 0.1);
    [-2.15, 2.15].forEach(px => {
        const pillar = new THREE.Mesh(pillarGeo, shelfMat);
        pillar.position.set(px, 4, 0.45);
        group.add(pillar);
    });
    
    scene.add(group);
    
    // Collider
    const worldPos = new THREE.Vector3(x, 4, z);
    if (rotY === Math.PI/2 || rotY === -Math.PI/2) {
        addCollider(x, 4, z, 1, 8, 4.5);
    } else {
        addCollider(x, 4, z, 4.5, 8, 1);
    }
    
    // Interactive zone
    if (!decorative && name && config) {
        const interactZone = new THREE.Mesh(
            new THREE.BoxGeometry(5, 8, 2),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        interactZone.position.set(x, 4, z + 0.8);
        interactZone.rotation.y = rotY;
        interactZone.userData = { type: name, ...config };
        interactiveObjects.push(interactZone);
        scene.add(interactZone);
    }
}

function createInstancedBooks() {
    const bookGeo = new THREE.BoxGeometry(1, 1, 1);
    const bookMat = new THREE.MeshStandardMaterial({
        roughness: 0.85,
        metalness: 0.05
    });
    
    const instanceCount = CONFIG.books.totalCount;
    bookInstances = new THREE.InstancedMesh(bookGeo, bookMat, instanceCount);
    bookInstances.castShadow = true;
    bookInstances.receiveShadow = true;
    
    const matrix = new THREE.Matrix4();
    const position = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    const color = new THREE.Color();
    
    // Shelf positions for book placement
    const shelfConfigs = [
        // Giant back wall bookshelf (behind player, 5 sections, 8 shelves each)
        { x: -5.5, z: 6.3, rotY: Math.PI, shelves: 8, width: 2.5 },
        { x: -2.5, z: 6.3, rotY: Math.PI, shelves: 8, width: 2.5 },
        { x: 0.5, z: 6.3, rotY: Math.PI, shelves: 8, width: 2.5 },
        { x: 2.5, z: 6.3, rotY: Math.PI, shelves: 8, width: 2.5 },
        { x: 5.5, z: 6.3, rotY: Math.PI, shelves: 8, width: 2.5 },
        // Left wall shelves
        { x: -8.4, z: 0, rotY: Math.PI/2, shelves: 7, width: 1.8 },
        { x: -8.4, z: 3, rotY: Math.PI/2, shelves: 7, width: 1.8 },
        // Right wall shelves
        { x: 8.4, z: 0, rotY: -Math.PI/2, shelves: 7, width: 1.8 },
        { x: 8.4, z: 3, rotY: -Math.PI/2, shelves: 7, width: 1.8 },
    ];
    
    let bookIndex = 0;
    
    shelfConfigs.forEach(config => {
        const halfWidth = (config.width || 1.8) / 2;
        for (let shelfY = 0; shelfY < config.shelves; shelfY++) {
            const y = 0.9 + shelfY * 0.95;  // Tighter shelf spacing
            let localX = -halfWidth + 0.1;
            
            while (localX < halfWidth - 0.1 && bookIndex < instanceCount) {
                const bookWidth = 0.05 + Math.random() * 0.1;
                const bookHeight = 0.45 + Math.random() * 0.4;
                const bookDepth = 0.3 + Math.random() * 0.2;
                
                // Random slight lean
                const lean = (Math.random() - 0.5) * 0.08;
                
                // Calculate world position
                if (config.rotY === 0) {
                    position.set(config.x + localX, y + bookHeight/2, config.z);
                } else if (config.rotY === Math.PI/2) {
                    position.set(config.x, y + bookHeight/2, config.z + localX);
                } else {
                    position.set(config.x, y + bookHeight/2, config.z - localX);
                }
                
                quaternion.setFromEuler(new THREE.Euler(0, config.rotY + lean, lean * 0.5));
                scale.set(bookWidth, bookHeight, bookDepth);
                
                matrix.compose(position, quaternion, scale);
                bookInstances.setMatrixAt(bookIndex, matrix);
                
                // Random color from palette
                const colorHex = CONFIG.books.colorsSpine[
                    Math.floor(Math.random() * CONFIG.books.colorsSpine.length)
                ];
                color.setHex(colorHex);
                bookInstances.setColorAt(bookIndex, color);
                
                localX += bookWidth + 0.01 + Math.random() * 0.02;
                
                // Occasional gap
                if (Math.random() < 0.08) localX += 0.1;
                
                bookIndex++;
            }
        }
    });
    
    // Add some books on floor (fallen/stacked)
    for (let i = 0; i < 30 && bookIndex < instanceCount; i++) {
        const stackX = -3 + Math.random() * 6;
        const stackZ = -4 + Math.random() * 8;
        
        for (let j = 0; j < 3 + Math.floor(Math.random() * 4) && bookIndex < instanceCount; j++) {
            const bookWidth = 0.15 + Math.random() * 0.1;
            const bookHeight = 0.02 + Math.random() * 0.02;
            const bookDepth = 0.25 + Math.random() * 0.1;
            
            position.set(
                stackX + (Math.random() - 0.5) * 0.1,
                0.01 + j * 0.025,
                stackZ + (Math.random() - 0.5) * 0.1
            );
            
            quaternion.setFromEuler(new THREE.Euler(
                Math.PI/2,
                Math.random() * 0.5,
                0
            ));
            scale.set(bookWidth, bookHeight, bookDepth);
            
            matrix.compose(position, quaternion, scale);
            bookInstances.setMatrixAt(bookIndex, matrix);
            
            color.setHex(CONFIG.books.colorsSpine[
                Math.floor(Math.random() * CONFIG.books.colorsSpine.length)
            ]);
            bookInstances.setColorAt(bookIndex, color);
            
            bookIndex++;
        }
    }
    
    bookInstances.instanceMatrix.needsUpdate = true;
    bookInstances.instanceColor.needsUpdate = true;
    scene.add(bookInstances);
}

// ============================================================================
// DESK AND ORB
// ============================================================================
function createDesk() {
    const x = 0, y = 0, z = -3;
    const woodMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.woodLight,
        roughness: 0.5
    });
    const darkWoodMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.woodMedium,
        roughness: 0.6
    });
    
    // Desk top
    const top = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.12, 1.8), woodMat);
    top.position.set(x, 0.9, z);
    top.castShadow = true;
    top.receiveShadow = true;
    scene.add(top);
    
    // Drawers
    const drawerGeo = new THREE.BoxGeometry(0.8, 0.6, 1.5);
    [-1.2, 1.2].forEach(dx => {
        const drawer = new THREE.Mesh(drawerGeo, darkWoodMat);
        drawer.position.set(x + dx, 0.5, z);
        drawer.castShadow = true;
        scene.add(drawer);
        
        // Handle
        const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.04, 0.04),
            new THREE.MeshStandardMaterial({ color: 0x8b7355, metalness: 0.4 })
        );
        handle.position.set(x + dx, 0.5, z + 0.78);
        scene.add(handle);
    });
    
    // Legs
    const legGeo = new THREE.BoxGeometry(0.1, 0.9, 0.1);
    [[-1.6, -0.8], [-1.6, 0.8], [1.6, -0.8], [1.6, 0.8]].forEach(([lx, lz]) => {
        const leg = new THREE.Mesh(legGeo, darkWoodMat);
        leg.position.set(x + lx, 0.45, z + lz);
        leg.castShadow = true;
        scene.add(leg);
    });
    
    // Props on desk
    // Papers
    for (let i = 0; i < 4; i++) {
        const paper = new THREE.Mesh(
            new THREE.PlaneGeometry(0.3 + Math.random() * 0.2, 0.4 + Math.random() * 0.2),
            new THREE.MeshStandardMaterial({ 
                color: 0xf5e6d3, 
                side: THREE.DoubleSide,
                roughness: 0.9 
            })
        );
        paper.rotation.x = -Math.PI / 2;
        paper.rotation.z = (Math.random() - 0.5) * 0.4;
        paper.position.set(
            x - 0.8 + Math.random() * 0.6,
            0.97,
            z + (Math.random() - 0.5) * 0.6
        );
        scene.add(paper);
    }
    
    // Ink bottle
    const inkBottle = new THREE.Mesh(
        new THREE.CylinderGeometry(0.04, 0.05, 0.1, 12),
        new THREE.MeshStandardMaterial({ color: 0x1a1a2a, roughness: 0.3 })
    );
    inkBottle.position.set(x - 1.2, 1.02, z - 0.3);
    scene.add(inkBottle);
    
    // Quill
    const quillGeo = new THREE.ConeGeometry(0.01, 0.25, 8);
    const quill = new THREE.Mesh(quillGeo, new THREE.MeshStandardMaterial({ color: 0xf5f5f0 }));
    quill.rotation.z = Math.PI / 6;
    quill.position.set(x - 1.1, 1.05, z - 0.3);
    scene.add(quill);
    
    // Open book
    const openBookGeo = new THREE.BoxGeometry(0.35, 0.02, 0.5);
    const openBook = new THREE.Mesh(openBookGeo, new THREE.MeshStandardMaterial({ color: 0xf5e6d3 }));
    openBook.position.set(x + 0.3, 0.97, z);
    openBook.rotation.y = 0.1;
    scene.add(openBook);
    
    // Collider
    addCollider(x, 0.5, z, 3.8, 1, 2);
    
    // Interactive zone
    const interactZone = new THREE.Mesh(
        new THREE.BoxGeometry(4, 2, 2.5),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    interactZone.position.set(x, 1, z + 0.5);
    interactZone.userData = { type: 'desk', ...CONFIG.interactives.desk };
    interactiveObjects.push(interactZone);
    scene.add(interactZone);
}

function createMagicOrb() {
    const x = 0.8, y = 0.97, z = -3;
    
    // Stand
    const standMat = new THREE.MeshStandardMaterial({
        color: 0x4a3a2a,
        metalness: 0.3,
        roughness: 0.6
    });
    const stand = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.16, 0.12, 16), standMat);
    stand.position.set(x, y + 0.06, z);
    scene.add(stand);
    
    // Orb
    const orbMat = new THREE.MeshBasicMaterial({
        color: 0x5588bb,
        transparent: true,
        opacity: 0.75
    });
    const orb = new THREE.Mesh(new THREE.SphereGeometry(0.15, 32, 32), orbMat);
    orb.position.set(x, y + 0.27, z);
    scene.add(orb);
    
    // Outer glow
    const glowMat = new THREE.MeshBasicMaterial({
        color: 0x88aadd,
        transparent: true,
        opacity: 0.15,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide
    });
    orbGlow = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32), glowMat);
    orbGlow.position.set(x, y + 0.27, z);
    scene.add(orbGlow);
    
    // Light
    orbLight = new THREE.PointLight(0x6699cc, CONFIG.lighting.orbIntensity, 4);
    orbLight.position.set(x, y + 0.27, z);
    scene.add(orbLight);
    
    // Magical dust particles around orb
    createOrbDustParticles(x, y + 0.27, z);
    
    // Interactive zone
    const interactZone = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 8, 8),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    interactZone.position.set(x, y + 0.27, z);
    interactZone.userData = { type: 'orb', ...CONFIG.interactives.orb };
    interactiveObjects.push(interactZone);
    scene.add(interactZone);
}

function createOrbDustParticles(cx, cy, cz) {
    const count = CONFIG.particles.orbDustCount;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const r = 0.2 + Math.random() * 0.3;
        
        positions[i * 3] = cx + r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = cy + r * Math.cos(phi);
        positions[i * 3 + 2] = cz + r * Math.sin(phi) * Math.sin(theta);
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.userData = {
        center: new THREE.Vector3(cx, cy, cz),
        angles: new Float32Array(count).fill(0).map(() => Math.random() * Math.PI * 2),
        speeds: new Float32Array(count).fill(0).map(() => 0.3 + Math.random() * 0.5),
        radii: new Float32Array(count).fill(0).map(() => 0.2 + Math.random() * 0.3),
        yOffsets: new Float32Array(count).fill(0).map(() => (Math.random() - 0.5) * 0.4)
    };
    
    const material = new THREE.PointsMaterial({
        size: 0.02,
        color: 0xaaccff,
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    
    orbDustParticles = new THREE.Points(geometry, material);
    scene.add(orbDustParticles);
}

// ============================================================================
// OTHER INTERACTABLES
// ============================================================================
function createPotionShelf() {
    const x = 7.5, y = 2.5, z = -5;
    
    const shelfMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodMedium });
    const shelf = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.5), shelfMat);
    shelf.position.set(x, y, z);
    shelf.castShadow = true;
    scene.add(shelf);
    
    // Support brackets
    [-0.8, 0.8].forEach(dx => {
        const bracket = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.3, 0.4),
            shelfMat
        );
        bracket.position.set(x + dx, y - 0.15, z);
        scene.add(bracket);
    });
    
    // Potions with varied shapes
    const potionConfigs = [
        { dx: -0.7, color: 0x44aa55, h: 0.18 },
        { dx: -0.35, color: 0xaa44aa, h: 0.22 },
        { dx: 0, color: 0xaaaa44, h: 0.15 },
        { dx: 0.35, color: 0xaa4444, h: 0.2 },
        { dx: 0.7, color: 0x4466aa, h: 0.17 }
    ];
    
    potionConfigs.forEach(conf => {
        const bottleGeo = new THREE.CylinderGeometry(0.04, 0.06, conf.h, 12);
        const bottleMat = new THREE.MeshStandardMaterial({
            color: conf.color,
            transparent: true,
            opacity: 0.7,
            roughness: 0.2
        });
        const bottle = new THREE.Mesh(bottleGeo, bottleMat);
        bottle.position.set(x + conf.dx, y + 0.04 + conf.h/2, z);
        bottle.castShadow = true;
        scene.add(bottle);
        
        // Cork
        const cork = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.03, 0.03, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b7355 })
        );
        cork.position.set(x + conf.dx, y + 0.04 + conf.h + 0.015, z);
        scene.add(cork);
    });
    
    // Interactive
    const interactZone = new THREE.Mesh(
        new THREE.BoxGeometry(2.5, 1.5, 1),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    interactZone.position.set(x, y, z);
    interactZone.userData = { type: 'potions', ...CONFIG.interactives.potions };
    interactiveObjects.push(interactZone);
    scene.add(interactZone);
}

function createBells() {
    const x = -7.5, y = 4.2, z = -5.5;
    
    const bellSizes = [0.08, 0.1, 0.12, 0.1, 0.08];
    const bellMat = new THREE.MeshStandardMaterial({
        color: 0xd4a855,
        metalness: 0.7,
        roughness: 0.25
    });
    
    bellSizes.forEach((size, i) => {
        const bell = new THREE.Mesh(
            new THREE.ConeGeometry(size, size * 1.8, 16),
            bellMat
        );
        bell.position.set(x - 0.4 + i * 0.2, y, z);
        bell.rotation.x = Math.PI;
        bell.castShadow = true;
        scene.add(bell);
        
        // String
        const string = new THREE.Mesh(
            new THREE.CylinderGeometry(0.005, 0.005, 0.15, 8),
            new THREE.MeshBasicMaterial({ color: 0x5a4a3a })
        );
        string.position.set(x - 0.4 + i * 0.2, y + size * 1.8 / 2 + 0.075, z);
        scene.add(string);
    });
    
    // Interactive
    const interactZone = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 0.8, 0.5),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    interactZone.position.set(x, y, z);
    interactZone.userData = { type: 'bells', ...CONFIG.interactives.bells };
    interactiveObjects.push(interactZone);
    scene.add(interactZone);
}

function createStairs() {
    const x = 7.5, y = 0, z = 3;
    const stepMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodLight, roughness: 0.6 });
    
    for (let i = 0; i < 8; i++) {
        const step = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 0.35), stepMat);
        step.position.set(x, 0.15 + i * 0.35, z - i * 0.4);
        step.castShadow = true;
        step.receiveShadow = true;
        scene.add(step);
        
        addCollider(x, 0.15 + i * 0.35, z - i * 0.4, 2, 0.35, 0.4);
    }
    
    // Railing
    const railMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodMedium });
    const rail = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.8, 3.5), railMat);
    rail.position.set(x + 1.1, 1.8, z - 1.4);
    rail.rotation.x = Math.atan(0.35 / 0.4);
    scene.add(rail);
    addCollider(x + 1.1, 1.8, z - 1.4, 0.15, 1.5, 3.5);
    
    // Interactive
    const interactZone = new THREE.Mesh(
        new THREE.BoxGeometry(2.5, 3, 4),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    interactZone.position.set(x, 1.5, z - 1);
    interactZone.userData = { type: 'stairs', ...CONFIG.interactives.stairs };
    interactiveObjects.push(interactZone);
    scene.add(interactZone);
}

function createMezzanine() {
    const mezzMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodLight, roughness: 0.6 });
    const railMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodMedium });
    
    // Platform
    const platform = new THREE.Mesh(new THREE.BoxGeometry(5, 0.15, 4), mezzMat);
    platform.position.set(6.5, 3, 1);
    platform.castShadow = true;
    platform.receiveShadow = true;
    scene.add(platform);
    addCollider(6.5, 3, 1, 5, 0.2, 4);
    
    // Railing
    const frontRail = new THREE.Mesh(new THREE.BoxGeometry(5, 0.08, 0.08), railMat);
    frontRail.position.set(6.5, 3.9, 3);
    scene.add(frontRail);
    
    // Balusters
    for (let i = 0; i < 8; i++) {
        const baluster = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.8, 0.06), railMat);
        baluster.position.set(4.3 + i * 0.65, 3.5, 3);
        scene.add(baluster);
    }
    addCollider(6.5, 3.5, 3.1, 5, 1, 0.2);
    
    // Support beams
    [4.5, 8.5].forEach(px => {
        const beam = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3, 0.2), mezzMat);
        beam.position.set(px, 1.5, -0.5);
        beam.castShadow = true;
        scene.add(beam);
        addCollider(px, 1.5, -0.5, 0.3, 3, 0.3);
    });
}

// ============================================================================
// PROPS AND DETAILS
// ============================================================================
function createProps() {
    // Globe on mezzanine
    const globeStand = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.2, 0.8, 16),
        new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodMedium })
    );
    globeStand.position.set(5.5, 3.55, 1);
    scene.add(globeStand);
    
    const globe = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 32, 32),
        new THREE.MeshStandardMaterial({ color: 0x2a5a4a, roughness: 0.4 })
    );
    globe.position.set(5.5, 4.3, 1);
    globe.castShadow = true;
    scene.add(globe);
    
    // Ladder against bookshelf
    const ladderMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodLight });
    const ladderGroup = new THREE.Group();
    
    // Rails
    [-0.25, 0.25].forEach(dx => {
        const rail = new THREE.Mesh(new THREE.BoxGeometry(0.05, 3.5, 0.05), ladderMat);
        rail.position.set(dx, 1.75, 0);
        ladderGroup.add(rail);
    });
    
    // Rungs
    for (let i = 0; i < 10; i++) {
        const rung = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.04, 0.04), ladderMat);
        rung.position.set(0, 0.3 + i * 0.35, 0);
        ladderGroup.add(rung);
    }
    
    ladderGroup.position.set(-4, 0, -6.3);
    ladderGroup.rotation.x = -0.15;
    scene.add(ladderGroup);
    addCollider(-4, 1.75, -6.3, 0.6, 3.5, 0.2);
    
    // Carpet near fireplace
    const carpetGeo = new THREE.PlaneGeometry(3, 2);
    const carpetMat = new THREE.MeshStandardMaterial({
        color: 0x4a2a2a,
        roughness: 0.9
    });
    const carpet = new THREE.Mesh(carpetGeo, carpetMat);
    carpet.rotation.x = -Math.PI / 2;
    carpet.position.set(-6, 0.005, -3);
    scene.add(carpet);
    
    // Carpet pattern (simple border)
    const borderGeo = new THREE.PlaneGeometry(2.6, 1.6);
    const borderMat = new THREE.MeshBasicMaterial({ color: 0x3a1a1a });
    const border = new THREE.Mesh(borderGeo, borderMat);
    border.rotation.x = -Math.PI / 2;
    border.position.set(-6, 0.006, -3);
    scene.add(border);
    
    // Armchair
    createArmchair(-5, 0, -2);
    
    // Candelabra on desk
    createCandelabra(-0.5, 0.97, -3.2);
}

function createArmchair(x, y, z) {
    const chairMat = new THREE.MeshStandardMaterial({ color: 0x4a2515, roughness: 0.8 });
    const woodMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodMedium });
    
    // Seat
    const seat = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.15, 0.6), chairMat);
    seat.position.set(x, y + 0.4, z);
    seat.castShadow = true;
    scene.add(seat);
    
    // Back
    const back = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 0.12), chairMat);
    back.position.set(x, y + 0.85, z - 0.25);
    back.castShadow = true;
    scene.add(back);
    
    // Arms
    [-0.38, 0.38].forEach(dx => {
        const arm = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.25, 0.5), chairMat);
        arm.position.set(x + dx, y + 0.55, z);
        scene.add(arm);
    });
    
    // Legs
    const legGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.35, 8);
    [[-0.28, -0.22], [-0.28, 0.22], [0.28, -0.22], [0.28, 0.22]].forEach(([dx, dz]) => {
        const leg = new THREE.Mesh(legGeo, woodMat);
        leg.position.set(x + dx, y + 0.175, z + dz);
        scene.add(leg);
    });
    
    addCollider(x, y + 0.5, z, 0.9, 1.2, 0.8);
}

function createCandelabra(x, y, z) {
    const brassMat = new THREE.MeshStandardMaterial({
        color: 0xb8860b,
        metalness: 0.6,
        roughness: 0.3
    });
    
    // Base
    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.05, 16), brassMat);
    base.position.set(x, y + 0.025, z);
    scene.add(base);
    
    // Stem
    const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 0.2, 8), brassMat);
    stem.position.set(x, y + 0.15, z);
    scene.add(stem);
    
    // Arms and candles
    [-0.08, 0, 0.08].forEach((dx, i) => {
        const candleY = y + 0.25 + (i === 1 ? 0.05 : 0);
        
        // Arm
        if (i !== 1) {
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.02), brassMat);
            arm.position.set(x + dx/2, y + 0.22, z);
            scene.add(arm);
        }
        
        // Holder
        const holder = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.02, 0.03, 8), brassMat);
        holder.position.set(x + dx, candleY, z);
        scene.add(holder);
        
        // Candle
        const candle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015, 0.018, 0.08, 8),
            new THREE.MeshStandardMaterial({ color: 0xf5e6d3 })
        );
        candle.position.set(x + dx, candleY + 0.055, z);
        scene.add(candle);
        
        // Flame
        const flame = new THREE.Mesh(
            new THREE.SphereGeometry(0.012, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xffaa44 })
        );
        flame.position.set(x + dx, candleY + 0.1, z);
        floatingCandles.push({ mesh: flame, baseY: candleY + 0.1 });
        scene.add(flame);
    });
}

// ============================================================================
// FLOATING CANDLES (at ceiling level)
// ============================================================================
function createFloatingCandles() {
    // Many more candles near the ceiling for better illumination
    const candlePositions = [
        // Main ceiling candles
        [-2, 7.5, -2], [2, 7.8, -1], [-1, 7.2, 1], [3, 7.6, 2],
        [-3, 7.4, 0], [1, 7.9, -3], [-4, 7.3, 2], [4, 7.7, -2],
        [0, 7.5, 0], [-5, 7.6, -4], [5, 7.4, -4], [0, 7.8, -5],
        [-2, 7.3, 3], [2, 7.5, 4], [-4, 7.7, -1], [4, 7.2, 1],
        // Lower floating candles
        [-6, 5.5, -2], [6, 5.8, -2], [-3, 5.2, 4], [3, 5.6, 4],
        [0, 6.0, 2], [-5, 5.4, 1], [5, 5.3, 0]
    ];
    
    candlePositions.forEach(([x, y, z]) => {
        // Candle body
        const candle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.035, 0.15, 8),
            new THREE.MeshStandardMaterial({ color: 0xf5e6d3 })
        );
        candle.position.set(x, y, z);
        candle.castShadow = true;
        scene.add(candle);
        
        // Flame
        const flame = new THREE.Mesh(
            new THREE.ConeGeometry(0.015, 0.04, 8),
            new THREE.MeshBasicMaterial({ color: 0xffaa33 })
        );
        flame.position.set(x, y + 0.095, z);
        scene.add(flame);
        
        // Glow
        const glow = new THREE.PointLight(0xff8833, 0.3, 2);
        glow.position.set(x, y + 0.1, z);
        scene.add(glow);
        
        floatingCandles.push({
            mesh: candle,
            flame,
            light: glow,
            baseY: y,
            phase: Math.random() * Math.PI * 2
        });
    });
}

// ============================================================================
// GOD RAYS (Bigger windows, more moonlight)
// ============================================================================
function createGodRays() {
    const rayMat = new THREE.MeshBasicMaterial({
        color: 0xaabbdd,
        transparent: true,
        opacity: 0.08,  // Stronger god rays
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    
    // Bigger windows on back wall
    const windows = [
        { x: -4.5, z: -6.85 },
        { x: 4.5, z: -6.85 }
    ];
    
    windows.forEach(win => {
        // Large arched window frame
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x3a3530, roughness: 0.7 });
        const frame = new THREE.Mesh(new THREE.BoxGeometry(3, 6.5, 0.25), frameMat);
        frame.position.set(win.x, 5, win.z);
        scene.add(frame);
        
        // Window arch top
        const arch = new THREE.Mesh(
            new THREE.TorusGeometry(1.3, 0.15, 8, 12, Math.PI),
            frameMat
        );
        arch.position.set(win.x, 7.8, win.z + 0.1);
        arch.rotation.x = Math.PI / 2;
        scene.add(arch);
        
        // Glass (glowing moonlight)
        const glassMat = new THREE.MeshBasicMaterial({
            color: 0x5566aa,
            transparent: true,
            opacity: 0.35
        });
        const glass = new THREE.Mesh(new THREE.PlaneGeometry(2.6, 5.8), glassMat);
        glass.position.set(win.x, 5, win.z + 0.13);
        scene.add(glass);
        
        // Mullions (window cross bars)
        const barMat = new THREE.MeshStandardMaterial({ color: 0x2a2520 });
        
        // Vertical bar
        const vBar = new THREE.Mesh(new THREE.BoxGeometry(0.08, 5.8, 0.08), barMat);
        vBar.position.set(win.x, 5, win.z + 0.14);
        scene.add(vBar);
        
        // Horizontal bars
        [-1.5, 0, 1.5].forEach(dy => {
            const hBar = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.06, 0.06), barMat);
            hBar.position.set(win.x, 5 + dy, win.z + 0.14);
            scene.add(hBar);
        });
        
        // God ray (larger cone)
        const ray = new THREE.Mesh(
            new THREE.ConeGeometry(4, 10, 8, 1, true),
            rayMat.clone()
        );
        ray.position.set(win.x, 2.5, win.z + 5);
        ray.rotation.x = Math.PI * 0.78;
        scene.add(ray);
        
        // Add point light at window for moonlight glow
        const windowLight = new THREE.PointLight(0x6688cc, 0.6, 8);
        windowLight.position.set(win.x, 5, win.z + 1);
        scene.add(windowLight);
    });
}

// ============================================================================
// DUST PARTICLES
// ============================================================================
function createDustParticles() {
    const count = CONFIG.particles.dustCount;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
        positions[i * 3] = (Math.random() - 0.5) * CONFIG.room.width;
        positions[i * 3 + 1] = Math.random() * CONFIG.room.height;
        positions[i * 3 + 2] = (Math.random() - 0.5) * CONFIG.room.depth;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.userData = {
        velocities: new Float32Array(count * 3).fill(0).map((_, i) => {
            const axis = i % 3;
            if (axis === 1) return 0.001 + Math.random() * 0.002;
            return (Math.random() - 0.5) * 0.001;
        })
    };
    
    const material = new THREE.PointsMaterial({
        size: 0.025,
        color: 0xffe8c8,
        transparent: true,
        opacity: 0.35,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    
    dustParticles = new THREE.Points(geometry, material);
    scene.add(dustParticles);
}

// ============================================================================
// FLOOR FOG
// ============================================================================
function createFloorFog() {
    const fogMat = new THREE.MeshBasicMaterial({
        color: 0x1a1815,
        transparent: true,
        opacity: CONFIG.fog.floorFogOpacity,
        side: THREE.DoubleSide,
        depthWrite: false
    });
    
    for (let layer = 0; layer < 4; layer++) {
        const fog = new THREE.Mesh(
            new THREE.PlaneGeometry(CONFIG.room.width, CONFIG.room.depth),
            fogMat.clone()
        );
        fog.rotation.x = -Math.PI / 2;
        fog.position.y = 0.05 + layer * 0.12;
        fog.material.opacity = CONFIG.fog.floorFogOpacity - layer * 0.05;
        scene.add(fog);
    }
}

// ============================================================================
// COLLISION DETECTION
// ============================================================================
function checkCollision(newPos) {
    const radius = CONFIG.player.radius;
    
    for (const box of colliders) {
        // Expand box by player radius
        const minX = box.min.x - radius;
        const maxX = box.max.x + radius;
        const minZ = box.min.z - radius;
        const maxZ = box.max.z + radius;
        
        // Check if player would be inside
        if (newPos.x > minX && newPos.x < maxX &&
            newPos.z > minZ && newPos.z < maxZ &&
            newPos.y > box.min.y && newPos.y < box.max.y + CONFIG.player.height) {
            return true;
        }
    }
    
    return false;
}

function resolveCollision(currentPos, desiredPos) {
    const result = desiredPos.clone();
    
    // Try X movement only
    const testX = new THREE.Vector3(desiredPos.x, currentPos.y, currentPos.z);
    if (!checkCollision(testX)) {
        result.x = desiredPos.x;
    } else {
        result.x = currentPos.x;
    }
    
    // Try Z movement only
    const testZ = new THREE.Vector3(result.x, currentPos.y, desiredPos.z);
    if (!checkCollision(testZ)) {
        result.z = desiredPos.z;
    } else {
        result.z = currentPos.z;
    }
    
    return result;
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onKeyDown(e) {
    if (!gameStarted) return;
    
    // When minigame is open, only ESC works
    if (isMinigameOpen) {
        if (e.code === 'Escape') {
            closeCurrentMinigame();
        }
        return;
    }
    
    switch(e.code) {
        case 'KeyW': case 'ArrowUp': moveForward = true; break;
        case 'KeyS': case 'ArrowDown': moveBackward = true; break;
        case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
        case 'KeyD': case 'ArrowRight': moveRight = true; break;
        case 'ShiftLeft': case 'ShiftRight':
            if (stamina > CONFIG.stamina.minToSprint) isSprinting = true;
            break;
        case 'KeyE': interact(); break;
        case 'Escape':
            if (bookPopup.classList.contains('visible')) {
                bookPopup.classList.remove('visible');
            }
            break;
    }
}

function closeCurrentMinigame() {
    for (let i = 1; i <= 8; i++) {
        const modal = document.getElementById('minigame' + i);
        if (modal && (modal.classList.contains('active') || modal.style.display !== 'none')) {
            doCloseMinigame(i);
            break;
        }
    }
}

// Custom close function that always works
function doCloseMinigame(num) {
    const modal = document.getElementById('minigame' + num);
    if (modal) {
        modal.classList.remove('active');
        modal.style.display = 'none';
    }
    isMinigameOpen = false;
}

function onKeyUp(e) {
    switch(e.code) {
        case 'KeyW': case 'ArrowUp': moveForward = false; break;
        case 'KeyS': case 'ArrowDown': moveBackward = false; break;
        case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
        case 'KeyD': case 'ArrowRight': moveRight = false; break;
        case 'ShiftLeft': case 'ShiftRight': isSprinting = false; break;
    }
}

function onClick(e) {
    if (!gameStarted) return;
    
    if (bookPopup.classList.contains('visible')) {
        bookPopup.classList.remove('visible');
        return;
    }
    
    if (!isPointerLocked && e.target.id === 'game-canvas') {
        document.body.requestPointerLock();
        return;
    }
    
    if (currentTarget) {
        interact();
    }
}

function onMouseMove(e) {
    if (!gameStarted || !isPointerLocked) return;
    
    const sensitivity = CONFIG.movement.mouseSensitivity;
    euler.y -= e.movementX * sensitivity;
    euler.x -= e.movementY * sensitivity;
    euler.x = Math.max(-Math.PI / 2.1, Math.min(Math.PI / 2.1, euler.x));
    
    camera.quaternion.setFromEuler(euler);
}

function onPointerLockChange() {
    isPointerLocked = document.pointerLockElement === document.body;
    crosshair.style.display = isPointerLocked ? 'block' : 'none';
}

// ============================================================================
// INTERACTION
// ============================================================================
function interact() {
    if (!currentTarget) return;
    
    const type = currentTarget.userData.type;
    const game = currentTarget.userData.game;
    
    if (type === 'fireplace') {
        intensifyFire();
        playSound(180, 'sawtooth', 0.6, 0.08);
        return;
    }
    
    if (type === 'orb') {
        pulseOrb();
        playSound(440, 'sine', 0.8, 0.15);
    }
    
    if (game) {
        document.exitPointerLock();
        isMinigameOpen = true;
        openMinigame(game);
    }
}

function intensifyFire() {
    const original = fireLight.intensity;
    fireLight.intensity = 6;
    fireLight.color.setHex(0xff8844);
    
    setTimeout(() => {
        fireLight.intensity = original;
        fireLight.color.setHex(0xff6622);
    }, 600);
}

function pulseOrb() {
    if (!orbGlow) return;
    
    const original = orbGlow.material.opacity;
    orbGlow.material.opacity = 0.5;
    orbLight.intensity = 2.5;
    
    setTimeout(() => {
        orbGlow.material.opacity = original;
        orbLight.intensity = CONFIG.lighting.orbIntensity;
    }, 800);
}

function playSound(freq, type, duration, volume = 0.2) {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(volume, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
}

// ============================================================================
// SETTINGS
// ============================================================================
function setupSettings() {
    document.getElementById('walkSpeedSlider').addEventListener('input', (e) => {
        CONFIG.movement.walkSpeed = parseFloat(e.target.value);
    });
    
    document.getElementById('sensitivitySlider').addEventListener('input', (e) => {
        CONFIG.movement.mouseSensitivity = 0.001 * parseFloat(e.target.value);
    });
    
    document.getElementById('bloomSlider').addEventListener('input', (e) => {
        renderer.toneMappingExposure = 0.5 + parseFloat(e.target.value) * 0.3;
    });
    
    document.getElementById('fogSlider').addEventListener('input', (e) => {
        scene.fog.far = parseFloat(e.target.value);
    });
}

function toggleSettings() {
    const panel = document.getElementById('settingsPanel');
    panel.classList.toggle('visible');
}

// ============================================================================
// ANIMATION LOOP
// ============================================================================
function animate() {
    requestAnimationFrame(animate);
    
    if (!gameStarted) {
        renderer.render(scene, camera);
        return;
    }
    
    const delta = Math.min(clock.getDelta(), 0.1);
    const time = clock.getElapsedTime();
    
    // Update movement
    updateMovement(delta, time);
    
    // Update stamina
    updateStamina(delta);
    
    // Raycast for interactions
    updateInteractionCheck();
    
    // Update particles
    updateFireParticles(time);
    updateEmberParticles(time, delta);
    updateDustParticles(delta);
    updateOrbDust(time);
    
    // Update lighting
    updateLighting(time);
    
    // Update floating candles
    updateFloatingCandles(time);
    
    renderer.render(scene, camera);
}

function updateMovement(delta, time) {
    if (!isPointerLocked) return;
    
    const isMoving = moveForward || moveBackward || moveLeft || moveRight;
    const canSprint = isSprinting && stamina > 0 && isMoving;
    const targetSpeed = canSprint ? CONFIG.movement.sprintSpeed : CONFIG.movement.walkSpeed;
    
    // Input direction
    inputDirection.z = Number(moveForward) - Number(moveBackward);
    inputDirection.x = Number(moveRight) - Number(moveLeft);
    inputDirection.normalize();
    
    // Calculate world direction from camera
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    forward.y = 0;
    forward.normalize();
    
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    right.y = 0;
    right.normalize();
    
    // Target velocity
    const targetVelocity = new THREE.Vector3();
    targetVelocity.addScaledVector(forward, inputDirection.z);
    targetVelocity.addScaledVector(right, inputDirection.x);
    targetVelocity.normalize().multiplyScalar(targetSpeed);
    
    // Smooth acceleration/deceleration
    const accel = isMoving ? CONFIG.movement.acceleration : CONFIG.movement.deceleration;
    velocity.x += (targetVelocity.x - velocity.x) * accel * delta;
    velocity.z += (targetVelocity.z - velocity.z) * accel * delta;
    
    // Calculate new position
    const newPos = playerPosition.clone();
    newPos.x += velocity.x * delta;
    newPos.z += velocity.z * delta;
    
    // Collision resolution
    const resolvedPos = resolveCollision(playerPosition, newPos);
    playerPosition.copy(resolvedPos);
    
    // Head bob
    if (CONFIG.headBob.enabled && isMoving && velocity.length() > 0.5) {
        headBobTime += delta * (canSprint ? CONFIG.headBob.sprintFrequency : CONFIG.headBob.walkFrequency);
        const amplitude = canSprint ? CONFIG.headBob.sprintAmplitude : CONFIG.headBob.walkAmplitude;
        const bobY = Math.sin(headBobTime) * amplitude;
        const bobX = Math.cos(headBobTime * 0.5) * amplitude * 0.5;
        
        camera.position.set(
            playerPosition.x + bobX,
            playerPosition.y + bobY,
            playerPosition.z
        );
    } else {
        // Smooth return to base position
        camera.position.x += (playerPosition.x - camera.position.x) * 5 * delta;
        camera.position.y += (playerPosition.y - camera.position.y) * 5 * delta;
        camera.position.z += (playerPosition.z - camera.position.z) * 5 * delta;
    }
}

function updateStamina(delta) {
    const isMoving = moveForward || moveBackward || moveLeft || moveRight;
    
    if (isSprinting && isMoving && stamina > 0) {
        stamina -= CONFIG.stamina.drainRate * delta;
        stamina = Math.max(0, stamina);
        staminaBar.classList.add('visible');
        
        if (stamina <= 0) {
            isSprinting = false;
        }
    } else if (stamina < CONFIG.stamina.max) {
        stamina += CONFIG.stamina.regenRate * delta;
        stamina = Math.min(CONFIG.stamina.max, stamina);
        
        if (stamina >= CONFIG.stamina.max) {
            staminaBar.classList.remove('visible');
        }
    }
    
    staminaFill.style.width = `${(stamina / CONFIG.stamina.max) * 100}%`;
}

function updateInteractionCheck() {
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(interactiveObjects);
    
    if (intersects.length > 0 && intersects[0].distance < 3.5) {
        const obj = intersects[0].object;
        if (!obj.userData.hidden) {
            currentTarget = obj;
            interactionPrompt.innerHTML = `<kbd>E</kbd> ${obj.userData.hint}`;
            interactionPrompt.classList.add('visible');
            return;
        }
    }
    
    currentTarget = null;
    interactionPrompt.classList.remove('visible');
}

function updateFireParticles(time) {
    if (!fireParticles) return;
    
    const positions = fireParticles.geometry.attributes.position.array;
    const colors = fireParticles.geometry.attributes.color.array;
    const { baseX, baseZ, velocities, lifetimes } = fireParticles.geometry.userData;
    
    for (let i = 0; i < CONFIG.particles.fireCount; i++) {
        lifetimes[i] += 0.025;
        
        if (lifetimes[i] > 1) {
            positions[i * 3] = baseX + (Math.random() - 0.5) * 1.5;
            positions[i * 3 + 1] = 0.3;
            positions[i * 3 + 2] = baseZ + 0.3;
            lifetimes[i] = 0;
        }
        
        positions[i * 3] += Math.sin(time * 8 + i) * 0.004;
        positions[i * 3 + 1] += velocities[i];
        
        const life = lifetimes[i];
        colors[i * 3] = 1.0 - life * 0.2;
        colors[i * 3 + 1] = 0.4 - life * 0.35;
        colors[i * 3 + 2] = 0.05;
    }
    
    fireParticles.geometry.attributes.position.needsUpdate = true;
    fireParticles.geometry.attributes.color.needsUpdate = true;
}

function updateEmberParticles(time, delta) {
    if (!emberParticles) return;
    
    const positions = emberParticles.geometry.attributes.position.array;
    const { baseX, baseZ, velocities, lifetimes } = emberParticles.geometry.userData;
    
    for (let i = 0; i < CONFIG.particles.emberCount; i++) {
        lifetimes[i] += delta * 0.3;
        
        if (lifetimes[i] > 1) {
            positions[i * 3] = baseX + (Math.random() - 0.5) * 1.5;
            positions[i * 3 + 1] = 1;
            positions[i * 3 + 2] = baseZ + (Math.random() - 0.5);
            lifetimes[i] = 0;
        }
        
        positions[i * 3] += velocities[i * 3] + Math.sin(time * 3 + i) * 0.002;
        positions[i * 3 + 1] += velocities[i * 3 + 1];
        positions[i * 3 + 2] += velocities[i * 3 + 2];
    }
    
    emberParticles.geometry.attributes.position.needsUpdate = true;
}

function updateDustParticles(delta) {
    if (!dustParticles) return;
    
    const positions = dustParticles.geometry.attributes.position.array;
    const { velocities } = dustParticles.geometry.userData;
    
    for (let i = 0; i < CONFIG.particles.dustCount; i++) {
        positions[i * 3] += velocities[i * 3];
        positions[i * 3 + 1] += velocities[i * 3 + 1];
        positions[i * 3 + 2] += velocities[i * 3 + 2];
        
        if (positions[i * 3 + 1] > CONFIG.room.height) {
            positions[i * 3 + 1] = 0;
            positions[i * 3] = (Math.random() - 0.5) * CONFIG.room.width;
            positions[i * 3 + 2] = (Math.random() - 0.5) * CONFIG.room.depth;
        }
    }
    
    dustParticles.geometry.attributes.position.needsUpdate = true;
}

function updateOrbDust(time) {
    if (!orbDustParticles) return;
    
    const positions = orbDustParticles.geometry.attributes.position.array;
    const { center, angles, speeds, radii, yOffsets } = orbDustParticles.geometry.userData;
    
    for (let i = 0; i < CONFIG.particles.orbDustCount; i++) {
        angles[i] += speeds[i] * 0.02;
        
        positions[i * 3] = center.x + Math.cos(angles[i]) * radii[i];
        positions[i * 3 + 1] = center.y + yOffsets[i] + Math.sin(time * 2 + i) * 0.05;
        positions[i * 3 + 2] = center.z + Math.sin(angles[i]) * radii[i];
    }
    
    orbDustParticles.geometry.attributes.position.needsUpdate = true;
}

function updateLighting(time) {
    // Fire flicker
    const flicker = Math.sin(time * 12) * 0.2 + Math.sin(time * 17) * 0.15 + Math.sin(time * 23) * 0.1;
    fireLight.intensity = CONFIG.lighting.fireIntensity + flicker * CONFIG.lighting.fireFlickerAmount;
    
    // Orb pulse
    if (orbLight) {
        orbLight.intensity = CONFIG.lighting.orbIntensity + Math.sin(time * 2) * 0.2;
    }
    
    if (orbGlow) {
        orbGlow.material.opacity = 0.12 + Math.sin(time * 1.5) * 0.04;
        orbGlow.scale.setScalar(1 + Math.sin(time * 1.8) * 0.08);
    }
}

function updateFloatingCandles(time) {
    floatingCandles.forEach((candle, i) => {
        if (candle.mesh) {
            const y = candle.baseY + Math.sin(time * 0.5 + (candle.phase || i)) * 0.15;
            candle.mesh.position.y = y;
            
            if (candle.flame) {
                candle.flame.position.y = y + 0.095;
            }
            if (candle.light) {
                candle.light.position.y = y + 0.1;
                candle.light.intensity = 0.25 + Math.sin(time * 8 + i) * 0.08;
            }
        }
    });
}

// ============================================================================
// GAME CONTROL
// ============================================================================
function startGame() {
    document.getElementById('introOverlay').classList.add('hidden');
    gameStarted = true;
    
    setTimeout(() => {
        interactionPrompt.innerHTML = 'Klicke um die Maussteuerung zu aktivieren';
        interactionPrompt.classList.add('visible');
        setTimeout(() => interactionPrompt.classList.remove('visible'), 3000);
    }, 500);
}

// Override solveMinigame and closeMinigame
window.addEventListener('load', () => {
    init();
    
    // Override openMinigame to set isMinigameOpen and handle display correctly
    const origOpen = window.openMinigame;
    window.openMinigame = function(num) {
        if (typeof num === 'string') {
            const slotIndex = parseInt(num.replace(/slot[LR]/, '')) - 1;
            num = num.startsWith('slotL') ? slotIndex + 1 : slotIndex + 5;
        }
        
        if (gameState.solved[num - 1]) {
            showMessage('Dieses R√§tsel wurde bereits gel√∂st! ‚ú®');
            return;
        }
        
        const modal = document.getElementById('minigame' + num);
        if (modal) {
            modal.style.display = 'flex';
            modal.classList.add('active');
            isMinigameOpen = true;
            initMinigame(num);
        }
    };
    
    // Override closeMinigame to always work and reset isMinigameOpen
    window.closeMinigame = function(num) {
        const modal = document.getElementById('minigame' + num);
        if (modal) {
            modal.classList.remove('active');
            modal.style.display = 'none';
        }
        isMinigameOpen = false;
    };
    
    // Also add click handlers to all close buttons for reliability
    document.querySelectorAll('.btn-close').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const modal = this.closest('.minigame-modal');
            if (modal) {
                modal.classList.remove('active');
                modal.style.display = 'none';
            }
            isMinigameOpen = false;
        });
    });
    
    const origSolve = window.solveMinigame;
    if (origSolve) {
        window.solveMinigame = function(num, artifact, number = null) {
            origSolve(num, artifact, number);
            
            const gem = document.querySelector(`.progress-gem[data-game="${num}"]`);
            if (gem) gem.classList.add('active');
            
            let solved = 0;
            for (let i = 1; i <= 7; i++) {
                if (gameState.solved[i - 1]) solved++;
            }
            
            if (solved >= 7) {
                const pensieve = interactiveObjects.find(o => o.userData.type === 'pensieve');
                if (pensieve) {
                    pensieve.userData.hidden = false;
                    showMessage('‚ú® Das Denkarium erwacht...', 'success');
                }
            }
        };
    }
});
</script>

<style>
.ingredient.placed { opacity: 0.3; pointer-events: none; }
.cauldron.drop-target { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6) !important; }
.cauldron.success { box-shadow: 0 0 30px rgba(100, 200, 100, 0.8) !important; }
.cauldron.error { animation: shake 0.5s ease-in-out; }
@keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-10px); } 75% { transform: translateX(10px); } }
</style>

</body>
</html>
